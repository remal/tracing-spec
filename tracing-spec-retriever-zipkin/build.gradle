import name.remal.gradle_plugins.dsl.artifact.CachedArtifactsCollection
import name.remal.version.Version

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

apply plugin: 'java-library'
apply plugin: 'name.remal.classes-relocation'

dependencies {
    relocateClasses project(':utils-refrofit')

    annotationProcessing('org.immutables:gson') { exclude group: 'com.google.code.gson' }

    api project(':tracing-spec-retriever')
    api 'org.apache.logging.log4j:log4j-api'

    integrationImplementation 'org.testcontainers:testcontainers'
    integrationImplementation 'io.zipkin.brave:brave'
    integrationImplementation 'io.zipkin.reporter2:zipkin-sender-urlconnection'
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

tasks.compileJava.doFirst {
    CachedArtifactsCollection classpathArtifacts = new CachedArtifactsCollection(classpath)
    println "classpathArtifacts: $classpathArtifacts"
    Configuration relocateClassesConf = configurations.relocateClasses
    println "relocateClassesConf: $relocateClassesConf"
    Configuration excludeFromClassesRelocationConf = configurations.excludeFromClassesRelocation
    println "excludeFromClassesRelocationConf: $excludeFromClassesRelocationConf"
    Configuration excludeFromForcedClassesRelocationConf = configurations.excludeFromForcedClassesRelocation
    println "excludeFromForcedClassesRelocationConf: $excludeFromForcedClassesRelocationConf"

    Set<String> internalClassNamesExcludedFromForcedRelocation = new CachedArtifactsCollection(
        excludeFromForcedClassesRelocationConf
    )
        .classNames
        .collect { it.replace('.', '/') }
        .toSet()
    println "internalClassNamesExcludedFromForcedRelocation:"
    internalClassNamesExcludedFromForcedRelocation.toSorted().forEach { println "  $it" }

    Set<String> possibleInternalClassNamesForForcedRelocation = classpathArtifacts.classNames
        .collect { it.replace('.', '/') }
        .findAll { !internalClassNamesExcludedFromForcedRelocation.contains(it) }
        .toSet()
    println "possibleInternalClassNamesForForcedRelocation:"
    possibleInternalClassNamesForForcedRelocation.toSorted().forEach { println "  $it" }

    Set<String> resourcesExcludedFromForcedRelocation = new CachedArtifactsCollection(
        excludeFromForcedClassesRelocationConf
    )
        .entryNames
    println "resourcesExcludedFromForcedRelocation:"
    resourcesExcludedFromForcedRelocation.toSorted().forEach { println "  $it" }

    Set<String> possibleResourcesForForcedRelocation = classpathArtifacts.entryNames
        .findAll { !resourcesExcludedFromForcedRelocation.contains(it) }
        .toSet()
    println "possibleResourcesForForcedRelocation:"
    possibleResourcesForForcedRelocation.toSorted().forEach { println "  $it" }

    Set<String> internalClassNamesExcludedFromRelocation = new CachedArtifactsCollection(
        excludeFromClassesRelocationConf
    )
        .classNames
        .collect { it.replace('.', '/') }
        .toSet()
    println "internalClassNamesExcludedFromRelocation:"
    internalClassNamesExcludedFromRelocation.toSorted().forEach { println "  $it" }

    Set<String> possibleInternalClassNamesForRelocation = new CachedArtifactsCollection(relocateClassesConf)
        .classNames
        .collect { it.replace('.', '/') }
        .findAll { !internalClassNamesExcludedFromRelocation.contains(it) }
        .toSet()
    println "possibleInternalClassNamesForRelocation:"
    possibleInternalClassNamesForRelocation.toSorted().forEach { println "  $it" }

    Set<String> resourcesExcludedFromRelocation = new CachedArtifactsCollection(excludeFromClassesRelocationConf)
        .entryNames
    println "resourcesExcludedFromRelocation:"
    resourcesExcludedFromRelocation.toSorted().forEach { println "  $it" }

    Set<String> possibleResourcesForRelocation = new CachedArtifactsCollection(relocateClassesConf)
        .entryNames
        .findAll { !resourcesExcludedFromRelocation.contains(it) }
        .toSet()
    println "possibleResourcesForRelocation:"
    possibleResourcesForRelocation.toSorted().forEach { println "  $it" }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

SourceSet versionTestSourceSet = sourceSets.integration
String baseVersionTestTaskName = versionTestSourceSet.getTaskName('test', null)

Task allTestVersionTask = tasks.create("$baseVersionTestTaskName-all-versions") {
    group = 'verification'
    tasks.runAllTests.dependsOn(it)
}

dockerImages.getAllTags('openzipkin/zipkin').forEach { String tagName ->
    Version version = Version.parseOrNull(tagName)
    // Only versions of <major>.<minor> format
    if (version == null || version.numbersCount != 2 || version.hasSuffix()) return

    // https://github.com/remal/tracing-spec/issues/19
    if (version < Version.create(2)) return

    TaskProvider<Task> testVersionTask = tasks.register("$baseVersionTestTaskName-$tagName", Test) {
        dependsOn(versionTestSourceSet.classesTaskName)

        systemProperty('zipkin-image-tag', tagName)

        Test baseTestTask = tasks[baseVersionTestTaskName]
        group = baseTestTask.group

        onlyIf {
            testClassesDirs = baseTestTask.testClassesDirs
            classpath = baseTestTask.classpath

            filter {
                includeTestsMatching('*VersionTest')
                failOnNoMatchingTests = true
            }

            return true
        }
    }

    allTestVersionTask.dependsOn(testVersionTask)
}
