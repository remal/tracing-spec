import static java.util.Collections.newSetFromMap

import groovy.json.JsonSlurper
import java.nio.file.Path
import java.time.ZonedDateTime
import java.util.Map.Entry
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import nl.javadude.gradle.plugins.license.License
import org.gradle.plugins.ide.idea.model.IdeaLanguageLevel
import org.jdom2.Document
import org.jdom2.input.SAXBuilder

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

buildscript {
    JavaVersion minimumJavaVersion = JavaVersion.VERSION_11
    if (JavaVersion.current() < minimumJavaVersion) {
        throw new GradleException("Minimum Java version for building the project is $minimumJavaVersion")
    }

    dependencies {
        classpath 'name.remal:gradle-plugins:1.0.208'
        classpath 'org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:3.0'
        classpath 'gradle.plugin.com.hierynomus.gradle.plugins:license-gradle-plugin:0.15.0'
        classpath 'org.jdom:jdom2:2.0.6'
        classpath 'gradle.plugin.org.jetbrains.gradle.plugin.idea-ext:gradle-idea-ext:0.8.1'
    }
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }

    configurations.classpath.allDependencies.all { Dependency dep ->
        if (dep instanceof ModuleDependency) {
            if (dep.version.endsWith("-SNAPSHOT")) {
                repositories {
                    mavenLocal()
                    maven { url = 'https://oss.sonatype.org/content/repositories/snapshots/' }
                }
                project.allprojects {
                    project.pluginManager.withPlugin('java') {
                        project.repositories {
                            mavenLocal()
                            maven { url = 'https://oss.sonatype.org/content/repositories/snapshots/' }
                        }
                    }
                }
            }
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

allprojects {
    group = 'name.remal.tracing-spec'
    version = '0.0.0-SNAPSHOT'

    apply plugin: 'name.remal.default-plugins'

    repositories {
        mavenCentral()
    }

    if (project.path != ':dependency-versions') {
        dependencies {
            allResolvable enforcedPlatform(project(':dependency-versions'))
            allResolvable enforcedPlatform('org.springframework.boot:spring-boot-dependencies')
            allResolvable platform('org.springframework.cloud:spring-cloud-sleuth-dependencies')
            allResolvable platform('io.grpc:grpc-bom')
            allResolvable platform('com.google.protobuf:protobuf-bom')
            allResolvable platform('org.testcontainers:testcontainers-bom')
            allResolvable platform('io.opentracing:parent')
            allResolvable platform('io.zipkin.brave:brave-bom')
            allResolvable platform('io.zipkin.reporter2:zipkin-reporter-bom')
        }
    }

    pluginManager.withPlugin('java') {
        apply plugin: 'name.remal.insert-null-checks'
        apply plugin: 'name.remal.module-info-generator'
        apply plugin: 'name.remal.integration-tests'
        apply plugin: 'checkstyle'
        apply plugin: 'jacoco'
        apply plugin: 'com.github.hierynomus.license'

        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8

        configurations {
            compileOnlyAllHidden { conf ->
                // We don't want IDE to index these dependencies, but they are required for compilation
                project.tasks.withType(AbstractCompile) {
                    onlyIf {
                        Collection<File> confFiles = conf.files
                        if (!confFiles.isEmpty()) {
                            classpath = classpath + project.files(confFiles)
                        }
                        return true
                    }
                }
            }
            staticAnalysis {
                compileOnly.extendsFrom(it)
                testImplementation.extendsFrom(it)
            }
            annotationProcessing {
                compileOnlyAll.extendsFrom(it)
                apt.extendsFrom(it)
            }
            optional {
                compileOnly.extendsFrom(it)
                testImplementation.extendsFrom(it)
            }
        }

        dependencies {
            components.all(RetrofitAlignmentRule)
            components.all(OkhttpAlignmentRule)
            components.all(JacocoAlignmentRule)

            staticAnalysis 'com.google.code.findbugs:jsr305'
            staticAnalysis 'com.google.errorprone:error_prone_annotations'
            staticAnalysis 'org.jetbrains:annotations'

            annotationProcessing 'name.remal:gradle-plugins-api'
            annotationProcessing 'org.projectlombok:lombok'
            annotationProcessing 'org.immutables:value'

            apt 'org.springframework.boot:spring-boot-configuration-processor'
            apt 'org.springframework.boot:spring-boot-autoconfigure-processor'
            apt 'org.hibernate.validator:hibernate-validator-annotation-processor'

            optional 'com.fasterxml.jackson.core:jackson-databind'
            optional 'org.hibernate.validator:hibernate-validator'
            optional('org.springframework.boot:spring-boot') { transitive = false }
            optional('org.springframework:spring-core') { transitive = false }
            optional('org.springframework:spring-context') { transitive = false }


            testImplementation 'org.junit.jupiter:junit-jupiter-api'
            testImplementation 'org.awaitility:awaitility'
            testImplementation 'org.hamcrest:hamcrest'
            testImplementation 'org.mockito:mockito-junit-jupiter'
            testImplementation 'org.mockito:mockito-inline'
            testImplementation 'com.google.guava:guava'
            testImplementation 'org.apache.commons:commons-lang3'

            testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
            testRuntimeOnly 'org.apache.logging.log4j:log4j-core'
            testRuntimeOnly 'org.apache.logging.log4j:log4j-slf4j-impl'
            testRuntimeOnly 'org.apache.logging.log4j:log4j-jul'
            testRuntimeOnly 'org.springframework:spring-jcl'


            integrationImplementation 'org.testcontainers:testcontainers'
        }

        if (project.path != ':utils-test') {
            dependencies {
                testImplementation project(':utils-test')
            }
        }

        transitiveDependencies {
            excludeStaticAnalysisTools()
        }

        configurations.all {
            resolutionStrategy {
                eachDependency { DependencyResolveDetails details ->
                    details.target.with {
                        String groupModule = "$group:$name"
                        if (groupModule == 'org.hamcrest:hamcrest-core') {
                            details.useTarget("$group:hamcrest:$version")

                        } else if (groupModule == 'org.springframework.boot:spring-boot-starter-logging') {
                            details.useTarget("$group:spring-boot-starter-log4j2:$version")
                        }
                    }
                }
            }
        }

        tasks.withType(JavaCompile) {
            options.compilerArgs.addAll(
                [
                    '-Werror',
                    '-Xlint:all',
                    '-Xlint:-rawtypes',
                    '-Xlint:-serial',
                    '-Xlint:-processing',
                ]
            )
        }

        testSourceSets.create('component')

        tasks.withType(Test) {
            useJUnitPlatform()

            List<String> jvmArgs = it.jvmArgs
            jvmArgs += '--illegal-access=deny'
            it.jvmArgs = jvmArgs

            systemProperty('java.util.logging.manager', 'org.apache.logging.log4j.jul.LogManager')
            systemProperty('spring.main.banner-mode', 'off')

            testLogging {
                events('FAILED')
            }

            Set<Object> testsWithStdErr = newSetFromMap(new ConcurrentHashMap<>())
            ConcurrentMap<Object, List<String>> testsMessages = new ConcurrentHashMap<>()
            onOutput { TestDescriptor descr, TestOutputEvent event ->
                if (event.destination.name() == 'StdErr') {
                    testsWithStdErr.add(descr.id)
                }

                List<String> testMessages = testsMessages.computeIfAbsent(descr.id, { new ArrayList<>() })
                testMessages.add(event.getMessage())
            }
            afterTest { TestDescriptor descr, TestResult result ->
                if (result.resultType.name() == 'FAILURE' || testsWithStdErr.contains(descr.id)) {
                    List<String> testMessages = testsMessages.get(descr.id)
                    if (testMessages != null) {
                        println()
                        println("Output of $descr.className > $descr.displayName:")
                        testMessages.forEach { print(" > $it") }
                    }
                }
            }
        }
    }

    pluginManager.withPlugin('name.remal.classes-relocation') {
        configurations.excludeFromForcedClassesRelocation.extendsFrom(configurations.staticAnalysis)

        classesRelocation {
            relocatedClassesPackageName = project.group.replaceAll(/[^\w.]/, '')
            if (project.path != ':') {
                relocatedClassesPackageName += project.path
                    .replace(':', '.')
                    .replace("${rootProject.name}-", '')
                    .replaceAll(/[^\w.]/, '.')
            }
            relocatedClassesPackageName += '.internal._relocated'
        }
    }

    pluginManager.withPlugin('checkstyle') {
        checkstyle {
            configDirectory = rootProject.projectDir
        }
    }

    pluginManager.withPlugin('maven-publish') {
        String prefix = rootProject.name + '-'
        if (!project.name.startsWith(prefix)) {
            throw new GradleScriptException(
                "Gradle plugin maven-publish can be applied only to projects with name prefixed with '$prefix'"
            )
        }
    }

    pluginManager.withPlugin('com.github.hierynomus.license') {
        File licenseTemplateFile = project.file('build/license-template.txt')
        TaskProvider<Task> prepareLicenseTemplate = tasks.register('prepareLicenseTemplate') {
            File ideaLicenseFile = rootProject.file('.idea/copyright/Apache_License_2_0.xml')
            inputs.file(ideaLicenseFile)
            outputs.file(licenseTemplateFile)

            doLast {
                licenseTemplateFile.delete()

                SAXBuilder saxBuilder = new SAXBuilder()
                Document document = saxBuilder.build(ideaLicenseFile)
                String licenseTemplate = document.rootElement
                    .getChildren('copyright')
                    .collect { it.getChildren('option') }.flatten()
                    .find { it.getAttributeValue('name') == 'notice' }
                    ?.getAttributeValue('value')
                if (licenseTemplate == null) {
                    throw new GradleScriptException('IDEA license template can\'t be retrieved ')
                }
                licenseTemplate = licenseTemplate.replaceAll(/(?:\$|&#36;)([\w.]+)/, '\\$\\{$1\\}')

                licenseTemplateFile.parentFile?.mkdirs()
                licenseTemplateFile.setText(licenseTemplate, 'UTF-8')

                didWork = true
            }
        }

        license {
            strictCheck = true

            header = licenseTemplateFile
            encoding = 'UTF-8'
            ext['today.year'] = Calendar.getInstance().get(Calendar.YEAR)

            useDefaultMappings = true
            mapping {
                java = 'IDEA_STYLE'
            }
            headerDefinitions {
                IDEA_STYLE {
                    firstLine = '/*'
                    beforeEachLine = ' * '
                    endLine = ' */\n'
                    afterEachLine = ''
                    skipLinePattern = null
                    firstLineDetectionPattern = /\s*\/\*.*$/
                    lastLineDetectionPattern = /.*\*\/\s*$/
                    allowBlankLines = false
                    isMultiline = true
                    padLines = false
                }
            }
        }

        tasks.withType(License).configureEach {
            dependsOn(prepareLicenseTemplate)

            include('**/*.java')

            Path generatedSourcesPath = project.buildDir.toPath()
            exclude { it.file.toPath().startsWith(generatedSourcesPath) }
        }

        pluginManager.withPlugin('java') {
            sourceSets.all { SourceSet sourceSet ->
                tasks.named(sourceSet.compileJavaTaskName).configure {
                    dependsOn(sourceSet.getTaskName('license', null))
                }
                tasks.named(sourceSet.processResourcesTaskName).configure {
                    dependsOn(sourceSet.getTaskName('license', null))
                }
            }
        }
    }
}

class RetrofitAlignmentRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext ctx) {
        ctx.details.with {
            if (id.group.matches(/com\.squareup\.retrofit\d*/)) {
                belongsTo("${id.group}:retrofit-bom:${id.version}", true)
            }
        }
    }
}

class OkhttpAlignmentRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext ctx) {
        ctx.details.with {
            if (id.group.matches(/com\.squareup\.okhttp\d*/)) {
                belongsTo("${id.group}:okhttp-bom:${id.version}", true)
            }
        }
    }
}

class JacocoAlignmentRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext ctx) {
        ctx.details.with {
            if (id.group == 'org.jacoco') {
                belongsTo("${id.group}:jacoco-bom:${id.version}")
            }
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

apply plugin: 'org.sonarqube'

allprojects {
    sonarqube {
        properties {
            property(
                'sonar.coverage.exclusions',
                [
                    '**/*Properties.java',
                ].join(',')
            )
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

class DockerImages {

    private static final ConcurrentMap<String, List<String>> getAllTagsCache = new ConcurrentHashMap<>()

    private final File cacheDir

    DockerImages(Project project) {
        cacheDir = project.rootProject.file('build/cache/dockerImages')
    }

    List<String> getAllTags(String image) {
        File cacheFile = new File(cacheDir, "getAllTags/$image")
        return getAllTagsCache.computeIfAbsent(image) {
            if (cacheFile.file) {
                return cacheFile.getText('UTF-8').readLines()
                    .collect { it.trim() }
                    .findAll { !it.isEmpty() }
            }

            Map<String, ZonedDateTime> tagsMap = new LinkedHashMap<>()
            int page = 0
            while (true) {
                ++page
                URL url = new URL("https://hub.docker.com/v2/repositories/$image/tags/?page=$page")
                HttpURLConnection connection = url.openConnection()
                connection.connectTimeout = 5000
                connection.readTimeout = 30000
                connection.useCaches = false
                connection.allowUserInteraction = false
                try {
                    int responseCode = connection.getResponseCode()
                    if (responseCode != 200) {
                        throw new GradleScriptException("Error retrieving GET $url: Status $responseCode")
                    }
                    String content = connection.inputStream.getText('UTF-8')
                    def json = new JsonSlurper().parseText(content)
                    if (json.results == null || json.results.isEmpty()) {
                        break
                    }
                    json.results.forEach { tagInfo ->
                        String tag = tagInfo.name
                        ZonedDateTime updatedAt = ZonedDateTime.parse(tagInfo.last_updated)
                        tagsMap.put(tag, updatedAt)
                    }
                } finally {
                    connection.disconnect()
                }
            }

            List<Entry<String, ZonedDateTime>> tagsMapEntries = tagsMap.entrySet().collect()
            tagsMapEntries.sort(Entry.comparingByValue())
            tagsMap = new LinkedHashMap<>()
            tagsMapEntries.forEach { tagsMap.put(it.key, it.value) }

            List<String> tags = tagsMap.keySet().collect()
            cacheFile.parentFile.mkdirs()
            cacheFile.setText(tags.join('\n'), 'UTF-8')

            return tags
        }
    }

}

allprojects {
    extensions.create('dockerImages', DockerImages.class, project)
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
forBuildOnLocal {
    apply plugin: 'java-library'

    repositories { gradlePluginPortal() }
    dependencies { runtimeOnly gradleApi() }

    dependencies { runtimeOnly 'name.remal:gradle-plugins' }
}
//*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

forBuildOnLocal {
    apply plugin: 'idea'
    apply plugin: 'org.jetbrains.gradle.plugin.idea-ext'

    idea {
        project {
            jdkName = '11'
            languageLevel = new IdeaLanguageLevel('8')
            targetBytecodeVersion = JavaVersion.VERSION_1_8

            settings {
                doNotDetectFrameworks('android', 'web')

                encodings {
                    encoding = 'UTF-8'
                    bomPolicy = 'WITH_NO_BOM'
                    properties {
                        encoding = 'US-ASCII'
                        transparentNativeToAsciiConversion = true
                    }
                }
            }
        }
    }
}
