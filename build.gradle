import static java.util.Collections.newSetFromMap

import groovy.json.JsonSlurper
import java.nio.file.Path
import java.time.ZonedDateTime
import java.util.Map.Entry
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import nl.javadude.gradle.plugins.license.License
import org.gradle.plugins.ide.idea.model.IdeaLanguageLevel
import org.jdom2.Document
import org.jdom2.input.SAXBuilder

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

buildscript {
    dependencies {
        classpath 'name.remal:gradle-plugins:1.0.200'
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:3.0"
        classpath "gradle.plugin.com.hierynomus.gradle.plugins:license-gradle-plugin:0.15.0"
        classpath 'org.jdom:jdom2:2.0.6'
        classpath 'gradle.plugin.org.jetbrains.gradle.plugin.idea-ext:gradle-idea-ext:0.7'
    }
    repositories {
        jcenter()
        gradlePluginPortal()
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

allprojects {
    group = 'name.remal.tracing-spec'
    version = '0.0.0-SNAPSHOT'

    apply plugin: 'name.remal.default-plugins'

    repositories {
        jcenter()
    }

    if (project.path != ':dependency-versions') {
        dependencies {
            allResolvable enforcedPlatform(project(':dependency-versions'))
            allResolvable enforcedPlatform('org.springframework.boot:spring-boot-dependencies')
            allResolvable platform('io.grpc:grpc-bom')
            allResolvable platform('com.google.protobuf:protobuf-bom')
            allResolvable platform('org.testcontainers:testcontainers-bom')
            allResolvable platform('io.opentracing:parent')
        }
    }

    pluginManager.withPlugin('java') {
        apply plugin: 'name.remal.insert-null-checks'
        apply plugin: 'name.remal.module-info-generator'
        apply plugin: 'name.remal.integration-tests'
        apply plugin: 'checkstyle'
        apply plugin: 'jacoco'
        apply plugin: 'com.github.hierynomus.license'

        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8

        configurations {
            compileOnlyAllHidden { conf ->
                // We don't want IDE to index these dependencies, but they are required for compilation
                project.afterEvaluate {
                    project.tasks.withType(AbstractCompile) {
                        onlyIf {
                            classpath += conf
                            return true
                        }
                    }
                }
            }
            staticAnalysis {
                compileOnly.extendsFrom(it)
                testImplementation.extendsFrom(it)
            }
            annotationProcessing {
                compileOnlyAll.extendsFrom(it)
                apt.extendsFrom(it)
            }
            optional {
                compileOnly.extendsFrom(it)
                testImplementation.extendsFrom(it)
            }
        }

        dependencies {
            components.all(JacocoAlignmentRule)

            staticAnalysis 'com.google.code.findbugs:jsr305'
            staticAnalysis 'com.google.errorprone:error_prone_annotations'
            staticAnalysis 'org.jetbrains:annotations'

            annotationProcessing 'name.remal:gradle-plugins-api'
            annotationProcessing 'org.projectlombok:lombok'
            annotationProcessing 'org.immutables:value'
            annotationProcessing 'org.immutables:metainf'

            apt 'org.springframework.boot:spring-boot-configuration-processor'
            apt 'org.hibernate.validator:hibernate-validator-annotation-processor'

            optional 'com.fasterxml.jackson.core:jackson-databind'
            optional 'org.hibernate.validator:hibernate-validator'
            optional('org.springframework.boot:spring-boot') { transitive = false }
            optional('org.springframework:spring-core') { transitive = false }
            optional('org.springframework:spring-context') { transitive = false }


            testImplementation 'org.junit.jupiter:junit-jupiter-api'
            testImplementation 'org.awaitility:awaitility'
            testImplementation 'org.hamcrest:hamcrest'
            testImplementation 'org.mockito:mockito-junit-jupiter'
            testImplementation 'org.mockito:mockito-inline'
            testImplementation 'com.google.guava:guava'
            testImplementation 'org.apache.commons:commons-lang3'

            testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
            testRuntimeOnly 'org.apache.logging.log4j:log4j-core'
            testRuntimeOnly 'org.apache.logging.log4j:log4j-slf4j-impl'
            testRuntimeOnly 'org.apache.logging.log4j:log4j-jcl'
        }

        transitiveDependencies {
            excludeStaticAnalysisTools()
        }

        configurations.all {
            resolutionStrategy {
                eachDependency { DependencyResolveDetails details ->
                    String groupModule = "${details.target.group}:${details.target.name}"
                    if ("$groupModule" == 'org.hamcrest:hamcrest-core') {
                        details.useTarget("org.hamcrest:hamcrest:${details.target.version}")
                    }
                }
            }
        }

        tasks.withType(JavaCompile) {
            options.compilerArgs.addAll(
                [
                    '-Werror',
                    '-Xlint:all',
                    '-Xlint:-rawtypes',
                    '-Xlint:-serial',
                    '-Xlint:-processing',
                ]
            )
        }

        tasks.withType(Test) {
            useJUnitPlatform()

            testLogging {
                events('FAILED')
            }

            Set<Object> testsWithStdErr = newSetFromMap(new ConcurrentHashMap<>())
            ConcurrentMap<Object, List<String>> testsMessages = new ConcurrentHashMap<>()
            onOutput { TestDescriptor descr, TestOutputEvent event ->
                if (event.destination.name() == 'StdErr') {
                    testsWithStdErr.add(descr.id)
                }

                List<String> testMessages = testsMessages.computeIfAbsent(descr.id, { new ArrayList<>() })
                testMessages.add(event.getMessage())
            }
            afterTest { TestDescriptor descr, TestResult result ->
                if (result.resultType.name() == 'FAILURE' || testsWithStdErr.contains(descr.id)) {
                    List<String> testMessages = testsMessages.get(descr.id)
                    if (testMessages != null) {
                        println()
                        println("Output of $descr.className > $descr.displayName:")
                        testMessages.forEach { print(" > $it") }
                    }
                }
            }
        }
    }

    pluginManager.withPlugin('name.remal.classes-relocation') {
        configurations.excludeFromForcedClassesRelocation.extendsFrom(configurations.staticAnalysis)

        classesRelocation {
            relocatedClassesPackageName = project.group.replaceAll(/[^\w.]/, '')
            if (project.path != ':') {
                relocatedClassesPackageName += project.path
                    .replace(':', '.')
                    .replace("${rootProject.name}-", '')
                    .replaceAll(/[^\w.]/, '.')
            }
            relocatedClassesPackageName += '.internal._relocated'
        }
    }

    pluginManager.withPlugin('checkstyle') {
        checkstyle {
            configDirectory = rootProject.projectDir
        }
    }

    pluginManager.withPlugin('com.github.hierynomus.license') {
        File licenseTemplateFile = project.file('build/license-template.txt')
        TaskProvider<Task> prepareLicenseTemplate = tasks.register('prepareLicenseTemplate') {
            File ideaLicenseFile = rootProject.file('.idea/copyright/Apache_License_2_0.xml')
            inputs.file(ideaLicenseFile)
            outputs.file(licenseTemplateFile)

            doLast {
                licenseTemplateFile.delete()

                SAXBuilder saxBuilder = new SAXBuilder()
                Document document = saxBuilder.build(ideaLicenseFile)
                String licenseTemplate = document.rootElement
                    .getChildren('copyright')
                    .collect { it.getChildren('option') }.flatten()
                    .find { it.getAttributeValue('name') == 'notice' }
                    ?.getAttributeValue('value')
                if (licenseTemplate == null) {
                    throw new GradleScriptException("IDEA license template can't be retrieved")
                }
                licenseTemplate = licenseTemplate.replaceAll(/(?:\$|&#36;)([\w.]+)/, '\\$\\{$1\\}')

                licenseTemplateFile.parentFile?.mkdirs()
                licenseTemplateFile.setText(licenseTemplate, 'UTF-8')

                didWork = true
            }
        }

        license {
            strictCheck = true

            header = licenseTemplateFile
            encoding = 'UTF-8'
            ext['today.year'] = Calendar.getInstance().get(Calendar.YEAR)

            useDefaultMappings = true
            mapping {
                java = 'IDEA_STYLE'
            }
            headerDefinitions {
                IDEA_STYLE {
                    firstLine = '/*'
                    beforeEachLine = ' * '
                    endLine = ' */\n'
                    afterEachLine = ''
                    skipLinePattern = null
                    firstLineDetectionPattern = /\s*\/\*.*$/
                    lastLineDetectionPattern = /.*\*\/\s*$/
                    allowBlankLines = false
                    isMultiline = true
                    padLines = false
                }
            }
        }

        tasks.withType(License).configureEach {
            dependsOn(prepareLicenseTemplate)

            include('**/*.java')

            Path generatedSourcesPath = project.buildDir.toPath()
            exclude { it.file.toPath().startsWith(generatedSourcesPath) }
        }

        pluginManager.withPlugin('java') {
            sourceSets.all { SourceSet sourceSet ->
                tasks.named(sourceSet.compileJavaTaskName).configure {
                    dependsOn(sourceSet.getTaskName('license', null))
                }
                tasks.named(sourceSet.processResourcesTaskName).configure {
                    dependsOn(sourceSet.getTaskName('license', null))
                }
            }
        }
    }
}

class JacocoAlignmentRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext ctx) {
        ctx.details.with {
            if (id.group == 'org.jacoco') {
                belongsTo("${id.group}:jacoco-bom:${id.version}")
            }
        }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

apply plugin: 'org.sonarqube'

tasks.named('sonarqube').configure {
    onlyIf {
        List<String> modules = properties['sonar.modules']?.split(/\s*,\s*/) ?: []
        List<String> propertyPrefixes = ['', modules.collect { "$it." }].flatten()
        propertyPrefixes.forEach { prefix ->
            if (properties[prefix + 'sonar.projectName'] == null) {
                throw new GradleScriptException("SonarQube property isn't set: " + prefix + 'sonar.projectName')
            }

            project.pluginManager.withPlugin('java') {
                project.pluginManager.withPlugin('name.remal.test-source-sets') {
                    properties[prefix + 'sonar.tests'] =
                        testSourceSets.collect { it.allSource.srcDirs }.flatten()
                            .unique().findAll { it.exists() }.join(",")
                    properties[prefix + 'sonar.java.test.binaries'] =
                        testSourceSets.collect { it.output.classesDirs }.flatten()
                            .unique().findAll { it.exists() }.join(",")
                    properties[prefix + 'sonar.java.test.libraries'] =
                        testSourceSets.collect { it.compileClasspath }.flatten()
                            .unique().findAll { it.exists() }.join(",")
                }
            }

            properties[prefix + 'sonar.java.checkstyle.reportPaths'] =
                tasks.withType(Checkstyle).collect { it.reports.xml.destination }
                    .unique().findAll { it.exists() }.join(",")

            properties[prefix + 'sonar.junit.reportPaths'] =
                tasks.withType(Test).collect { it.reports.junitXml.destination }
                    .unique().findAll { it.exists() }.join(",")

            properties[prefix + 'sonar.coverage.jacoco.xmlReportPaths'] =
                tasks.withType(JacocoReport).collect { it.reports.xml.destination }
                    .unique().findAll { it.exists() }.join(",")
        }

        return true
    }

    dependsOn {
        project.allprojects
            .collect { it.tasks }.flatten()
            .findAll {
                (
                    it.name == 'check'
                        || it instanceof Checkstyle
                        || it instanceof Test
                        || it instanceof JacocoReport
                )
            }
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

class DockerImages {

    private static final ConcurrentMap<String, List<String>> getAllTagsCache = new ConcurrentHashMap<>()

    private final File cacheDir

    DockerImages(Project project) {
        cacheDir = project.rootProject.file('build/cache/dockerImages')
    }

    List<String> getAllTags(String image) {
        File cacheFile = new File(cacheDir, "getAllTags/$image")
        return getAllTagsCache.computeIfAbsent(image) {
            if (cacheFile.file) {
                return cacheFile.getText('UTF-8').readLines()
                    .collect { it.trim() }
                    .findAll { !it.isEmpty() }
            }

            Map<String, ZonedDateTime> tagsMap = new LinkedHashMap<>()
            int page = 0
            while (true) {
                ++page
                URL url = new URL("https://hub.docker.com/v2/repositories/$image/tags/?page=$page")
                HttpURLConnection connection = url.openConnection()
                connection.connectTimeout = 5000
                connection.readTimeout = 30000
                connection.useCaches = false
                connection.allowUserInteraction = false
                try {
                    int responseCode = connection.getResponseCode()
                    if (responseCode != 200) {
                        throw new GradleScriptException("Error retrieving GET $url: Status $responseCode")
                    }
                    String content = connection.inputStream.getText('UTF-8')
                    def json = new JsonSlurper().parseText(content)
                    if (json.results == null || json.results.isEmpty()) {
                        break
                    }
                    json.results.forEach { tagInfo ->
                        String tag = tagInfo.name
                        ZonedDateTime updatedAt = ZonedDateTime.parse(tagInfo.last_updated)
                        tagsMap.put(tag, updatedAt)
                    }
                } finally {
                    connection.disconnect()
                }
            }

            List<Entry<String, ZonedDateTime>> tagsMapEntries = tagsMap.entrySet().collect()
            tagsMapEntries.sort(Entry.comparingByValue())
            tagsMap = new LinkedHashMap<>()
            tagsMapEntries.forEach { tagsMap.put(it.key, it.value) }

            List<String> tags = tagsMap.keySet().collect()
            cacheFile.parentFile.mkdirs()
            cacheFile.setText(tags.join('\n'), 'UTF-8')

            return tags
        }
    }

}

allprojects {
    extensions.create("dockerImages", DockerImages.class, project)
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
apply plugin: 'java-library'

repositories {
    gradlePluginPortal()
}

dependencies {
    runtimeOnly gradleApi()
}
//*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

forBuildOnLocal {
    apply plugin: 'idea'
    apply plugin: 'org.jetbrains.gradle.plugin.idea-ext'

    idea {
        project {
            jdkName = '1.8'
            languageLevel = new IdeaLanguageLevel('8')
            targetBytecodeVersion = JavaVersion.VERSION_1_8

            settings {
                doNotDetectFrameworks('android', 'web')

                encodings {
                    encoding = 'UTF-8'
                    bomPolicy = 'WITH_NO_BOM'
                    properties {
                        encoding = 'US-ASCII'
                        transparentNativeToAsciiConversion = true
                    }
                }
            }
        }
    }
}
